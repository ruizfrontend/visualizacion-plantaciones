<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<style>
	#prods .act, #years .act { color: red; }
</style>
<body>

<div id="prods">
	<a href="" data-prod="cacao" class="">Cacao</a>
	<a href="" data-prod="banana" class="">Banana</a>
	<a href="" data-prod="azucar" class="">Azucar</a>
	<a href="" data-prod="aceite" class="">Aceite</a>
	<a href="" data-prod="cafe" class="">Cafe</a>
</div>
<div id="years">
	<a href="" data-year="2004" class="">2004</a>
	<a href="" data-year="2005" class="">2005</a>
	<a href="" data-year="2006" class="">2006</a>
	<a href="" data-year="2007" class="">2007</a>
	<a href="" data-year="2008" class="">2008</a>
	<a href="" data-year="2009" class="">2009</a>
	<a href="" data-year="2010" class="">2010</a>
	<a href="" data-year="2011" class="">2011</a>
	<a href="" data-year="2012" class="">2012</a>
	<a href="" data-year="2013" class="">2013</a>
	<a href="" data-year="2014" class="">2014</a>
</div>

<svg id="viz"></svg>

<script src="http://estaticos.lab.eldiario.es/libs/jquery-1.10.2.min.js"></script>
<script src="http://d3js.org/d3.v2.min.js"></script>
<!-- <script src="http://estaticos.lab.eldiario.es/libs/topojson-2.2.0.min.js"></script> -->

<script>

var planta_graph = {

	pathData: './',
	pathPaises: './paises.json',

	actYear: 2014,
	actProd: 'cafe',

	ready: false, // semaforo carga inicial

	constants: {
		maxCirc: 20000, // max circle size 
	},

	viz: {
		width: 0,
		height: 0,
		$elm: null,
		svg: null,
		projection: null,
		path: null,
		map: null,
		circs: null,
		circ2: null,
	},

	data: {
		prod: null,
		countries: null,
		links: null,
		maxImp: null // importación máxima
	},

	init: function(){

		planta_graph.viz.$em = $('#viz');
		planta_graph.viz.svg = d3.select('#viz');
		
		planta_graph.tools.loadCountries();

			// jqueries
		$('#years a').click(planta_graph.evs.change_year);
		$('#prods a').click(planta_graph.evs.change_product);

		$('#years a[data-year=' +  planta_graph.actYear + ']').addClass('act');
		$('#prods a[data-prod=' +  planta_graph.actProd + ']').addClass('act');

		$(window).bind('orientationchange resize', throttle(planta_graph.tools.handleResize, 300));

		planta_graph.tools.handleResize();

		// planta_graph.tools.getProductos(planta_graph.actProd);
		planta_graph.tools.update();
	},

	evs: {
		change_product: function(e){
			
			e.preventDefault();
			
			$('#prods .act').removeClass('act');

			var prod = $(this).addClass('act').data('prod');
			if(!prod || planta_graph.actProd == prod) { console.log('no hay producto'); return; };

			planta_graph.actProd = prod;

				// carga datos nuevos y pinta
			planta_graph.tools.update();
			// planta_graph.tools.getProductos(prod);
		},
		change_year: function(e){
			
			e.preventDefault();

			$('#years .act').removeClass('act');
			
			var year = $(this).addClass('act').data('year');
			if(!year || planta_graph.actYear == year) { console.log('no hay año'); return; };

			planta_graph.actYear = year;

				// actualiza el dibujo
			planta_graph.tools.update();
		}
	},

	tools: {

		handleResize: function() {
			planta_graph.tools.updateProjection();
			// planta_graph.tools.initBG();
			
			if(planta_graph.ready) planta_graph.tools.draw();
			
			planta_graph.ready = true; // semaforo
		},

		updateProjection: function() {

		   	planta_graph.viz.width = $(window).width();
		   	planta_graph.viz.height = planta_graph.viz.width / 1.6;

		   	planta_graph.viz.$em.css({
		   		width: planta_graph.viz.width,
		   		height: planta_graph.viz.height
		   	});

		   	planta_graph.viz.projection = d3.geo.mercator();
			planta_graph.viz.projection.scale(170 * (planta_graph.viz.width / 1000));
			planta_graph.viz.projection.translate([planta_graph.viz.width / 2, planta_graph.viz.height / 2]);
			// planta_graph.viz.projection.precision(51);

			planta_graph.viz.path = d3.geo.path().projection(planta_graph.viz.projection);

			if(planta_graph.data.prod)
				for (var i = 0; i < planta_graph.data.prod.length; i++) {
					planta_graph.data.prod[i].posX = planta_graph.viz.projection([planta_graph.data.prod[i].lon, planta_graph.data.prod[i].lat])[0];
					planta_graph.data.prod[i].posY = planta_graph.viz.projection([planta_graph.data.prod[i].lon, planta_graph.data.prod[i].lat])[1];
				};

		},

		initBG: function() {

			d3.json("./world-50m.json", function(world, error) {
				if (error) throw error;

				var countries = topojson.feature(world, world.objects.countries).features;
				// var neighbors = topojson.neighbors(world.objects.countries.geometries);

				if(planta_graph.viz.map) planta_graph.viz.map.remove()

				planta_graph.viz.map = planta_graph.viz.svg.selectAll(".country")
					.data(countries)
					.enter()
						.insert("path", ".graticule")
							.attr('d', planta_graph.viz.path)
							.attr('class', "country")
							.style('stroke', '#ccc')
							.style('fill', 'none')
							.style('stroke-width', '1');

			});
		},

		loadCountries: function(cb) {

			d3.json(planta_graph.pathPaises, function(world, error) {
			  	
			  	if (error) throw error;

			  	var paises = [];
			  	for (var key in world) {
				  if (world.hasOwnProperty(key)) {
				    var pais = world[key];
				    pais.key = key;
				    pais.posX = planta_graph.viz.projection([pais.lon, pais.lat])[0];
				    pais.posY = planta_graph.viz.projection([pais.lon, pais.lat])[1];
				    paises.push(pais);
				  }
				}

				planta_graph.data.countries = paises;
				
				if(cb) cb();
			});
		},

		update: function() {
			d3.json(planta_graph.pathData + planta_graph.actProd + '.json', function(data, error){
			    
			    if (error) throw error;

			    	// si no hay paises los carga asyncronos
				if(!planta_graph.data.countries) planta_graph.tools.loadCountries(function(){ 
					
					planta_graph.tools.processData(data);
					planta_graph.tools.draw();

					return;
				});

				planta_graph.tools.processData(data);
				planta_graph.tools.draw();
			});
		},
		// updateCountries: function() {
		// 	for (var i = planta_graph.data.countries.length - 1; i >= 0; i--) {
		// 		planta_graph.data.countries[i]
		// 	};
		// },

		processData: function(data) {

			var countries = planta_graph.data.countries; // alias
			var actData = data[planta_graph.actYear];

			var links = [];

			planta_graph.data.maxImp = 0;
			planta_graph.data.maxExp = 0;

			for (var i = countries.length - 1; i >= 0; i--) {
				countries[i].totalImp = 0;
				countries[i].totalExp = 0;
			}

			for (var i = countries.length - 1; i >= 0; i--) {
				if(actData[countries[i].key]) {

					for (keyOut in actData[countries[i].key]) { 
						if(actData[countries[i].key].hasOwnProperty(keyOut)) {
							countries[i].totalImp = actData[countries[i].key][keyOut];

								// suma exportaciones
							for (var j = countries.length - 1; j >= 0; j--) {

								if(countries[j].key == keyOut) {
									countries[j].totalExp += actData[countries[i].key][keyOut];

									links.push({
										source: i,
										target: j,
										val: actData[countries[i].key][keyOut]
									})
								}
								
								if(planta_graph.data.maxImp < countries[j].totalExp)
									planta_graph.data.maxImp = countries[j].totalExp;

							}

						}
					};

				}
			}

			for (var i = countries.length - 1; i >= 0; i--) {
				countries[i].rTot = (planta_graph.constants.maxCirc * countries[i].totalImp / planta_graph.data.maxImp) / 2;
			}

			planta_graph.data.prod = countries;
			planta_graph.data.links = links;

		},

		draw: function() {
			// return;
			if(!planta_graph.viz.circs) {
				planta_graph.viz.circs = planta_graph.viz.svg.selectAll('.circ').data(planta_graph.data.prod).enter().append('circle').attr('class', 'circ');
				planta_graph.viz.circ2 = planta_graph.viz.svg.selectAll('.cir2').data(planta_graph.data.prod).enter().append('circle').attr('class', 'cir2');
				
			} else {
				planta_graph.viz.circs.data(planta_graph.data.prod);
				planta_graph.viz.circ2.data(planta_graph.data.prod);
			}

			planta_graph.viz.circs
				.attr('cx', function(d) { return d.posX; })
				.attr('cy', function(d) { return d.posY; })
				.attr("stroke", "red")
				.attr("fill", "none")
				.on("mouseenter", function(d){ console.log(d); })
				.transition()
				.duration(500)
				.attr('stroke-width', function(d) {
					return (planta_graph.constants.maxCirc * d.totalImp / planta_graph.data.maxImp);
				})
				.attr('r', function(d) { return d.rTot; });

				if(planta_graph.viz.force) planta_graph.viz.force.stop();

		      planta_graph.viz.force = d3.layout.force()
                		.nodes(planta_graph.data.prod)
		                .links(planta_graph.data.links)
		                .size([planta_graph.viz.width, planta_graph.viz.height])
		                .charge(0.1)
		                // .charge(function(d) {
		                // 	return 0.1;
		                //   // -Math.pow(d.radius*5.0, 2.0) / 8
		                // })
		                .gravity(4)
		                .on('tick', function(e) {

		                  k = 6 * e.alpha;
		                  
		                  for (i=0; i < planta_graph.data.prod.length; i++) {
		                    planta_graph.data.prod[i].x += (k * planta_graph.data.prod[i].posX) - planta_graph.viz.width
		                    planta_graph.data.prod[i].y += (k * planta_graph.data.prod[i].posY) - planta_graph.viz.height
		                  };

		                  planta_graph.viz.circs
		                     .each(collide(.1, planta_graph.data.prod, null))
		                     .attr('cx', function(e) { return e.x; })
		                     .attr('cy', function(e) { return e.y; });

		                  // svg.selectAll('text')
		                  //    .attr('x', function(node) { return node.x; })
		                  //    .attr('y', function(node) { return node.y+5; })
		                  //    .attr('opacity', function(node) {
		                  //      if (node.radius < 17) {
		                  //        return 0;
		                  //      }
		                  //      return 1;
		                  //    });
		                  //    ;
		                })
		                .start();

			console.log('draw')
return


			planta_graph.viz.circs
				.attr('cx', function(d) { return planta_graph.viz.projection([d.lon, d.lat])[0]; })
				.attr('cy', function(d) { return planta_graph.viz.projection([d.lon, d.lat])[1]; })
				.attr("stroke", "red")
				.attr("fill", "none")
				.on("mouseenter", function(d){ console.log(d); })
				.transition()
				.duration(500)
				.attr('stroke-width', function(d) {
					return (planta_graph.constants.maxCirc * d[planta_graph.actYear].totalImp / planta_graph.data.maxImp[planta_graph.actYear]);
				})
				.attr('r', function(d) { return (planta_graph.constants.maxCirc * d[planta_graph.actYear].totalImp / planta_graph.data.maxImp[planta_graph.actYear]) / 2; });

			planta_graph.viz.circ2
				.attr('cx', function(d) { return planta_graph.viz.projection([d.lon, d.lat])[0]; })
				.attr('cy', function(d) { return planta_graph.viz.projection([d.lon, d.lat])[1]; })
				.attr("stroke", "blue")
				.attr("fill", "none")
				.on("mouseenter", function(d){ console.log(d); })
				.transition()
				.duration(500)
				.attr('stroke-width', function(d) {
					return (planta_graph.constants.maxCirc * d[planta_graph.actYear].totalExp / planta_graph.data.maxImp[planta_graph.actYear]);
				})
				.attr('r', function(d) {
					var rImp = (planta_graph.constants.maxCirc * d[planta_graph.actYear].totalImp / planta_graph.data.maxImp[planta_graph.actYear]);
					var rExp = (planta_graph.constants.maxCirc * d[planta_graph.actYear].totalExp / planta_graph.data.maxImp[planta_graph.actYear]) / 2;
					return (rImp + (rExp / 2));
				});
				
		}
	}
};


planta_graph.init();

  var collide = function (alpha, nodes, scale) {
    
    var quadtree = d3.geom.quadtree(nodes);

    return function(d) {

      var r = d.rTot + 10;
      
      var nx1 = d.x - r;
      var nx2 = d.x + r;
      var ny1 = d.y - r;
      var ny2 = d.y + r;

      quadtree.visit(function(quad, x1, y1, x2, y2) {
      
        if (quad.point && quad.point !== d) {

          var x = d.x - quad.point.x;
          var y = d.y - quad.point.y;
          var l = Math.sqrt(x * x + y * y)
          var r = d.rTot + quad.point.rTot + 10;
      
          if (l < r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      });
    }
  }


function throttle (callback, limit) {   // http://sampsonblog.com/749/simple-throttle-function modificado!
    var wait = false;                 // Initially, we're not waiting
    return function () {              // We return a throttled function
        if (!wait) {                  // If we're not waiting
                                       // Execute users function
            wait = true;              // Prevent future invocations
            setTimeout(function () {  // After a period of time
                callback.call();
                wait = false;         // And allow future invocations
            }, limit);
        }
    }
}
</script>
</body>
</html>